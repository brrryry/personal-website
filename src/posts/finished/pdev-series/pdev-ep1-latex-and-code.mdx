---
title: "Portfolio Dev (Part 1): LaTeX and Code"
date: "2024-08-08"
description: "First detailed code analysis: my own portfolio! Take a look at my funky setup :D"
tags: ["portfolio-dev-series", "coding"]
---

As the school year comes in (I'm writing this in early August), I'm expecting to slow down my blog frequency
(even though this is not guaranteed to be the case). With this in mind, I would like to start documenting my
development process so that:

<BlogList>
  <li>
    I don't lose track of what I'm doing and don't end myself over deprecated
    packages in a year or so
  </li>
  <li>
    I can help other people understand how my blog works (and maybe even help
    them make their own one day)
  </li>
</BlogList>

This will be my first attempt at a more "formal" post - I'm hoping that this blog will have no glaring errors by the time I publish it.
After all, my last few blogs represented more of a tangent than an actual blog... \
\
I would like to express my gratitude to <a href="https://kevinthuhstink.com" target="_blank">this guy named Kevin</a> for reading my blogs, checking my errors and (cough cough) breaking my models. \
\
With this in mind, let's start diving into the code.

<br />

## Setting Up NextJS

**As of right now, I am using NextJS 14.2.5.** \
\
I set up my NextJS project the way the <a href="https://nextjs.org/docs/getting-started/installation" target="_blank">tutorial on their website</a> described.

<BlogCode language="bash">
  {`
npx create-next-app@latest
`}
</BlogCode>

Here were the settings that I used:

<BlogCode language="plaintext">
  {`
What is your project named? portfolio
Would you like to use TypeScript? No 
Would you like to use ESLint? No
Would you like to use Tailwind CSS? Yes
Would you like to use 'src/' directory? Yes
Would you like to use App Router? (recommended) Yes
Would you like to customize the default import alias (@/*)? No
What import alias would you like configured? @/*
`}
</BlogCode>

This will create a Next app in a folder with your project's name on it. \
I installed these packages for my blog, but not all of them are necessary (obviously).

<BlogList>
  <li>
    ``next-mdx-remote`` - parsing remote .mdx files (honestly not necessary). I
    only use it for the MDXRemote component.
  </li>
  <li>``gray-matter`` - parses frontmatter and content of .mdx files</li>
  <li>
    ``dompurify`` - protects against XSS attacks (specifically because I use
    HTML injection for code blocks)
  </li>
  <li>
    ``husky`` - pre-commit and pre-push linting/formatting (make your code look
    good and readable)
  </li>
  <li>``rehype`` - adds classes to code tags to enable fancy code CSS</li>
</BlogList>

You should familiarize yourself with the directories and what they are meant for. \
\
If you enter the directory of your project and run the command `npm run dev`, you should be able to view your website if you go to `localhost:3000` in your browser (I believe this is the default port - if it is not
3000, the terminal will tell you which port to
go to).

<BlogImage
  src="/blogs/pdev-ep1-latex-and-code/next-welcome.png"
  alt="Fig 1 - default Next page after setup"
  caption="Next@14.2.5: default page"
/>

That's essentially it for the setup, but now it's time for the coding. \
\
**Note: please keep in mind that I am using the App Router.**

<br />

## The Home Page!

The App Router works in a way such that each folder is a route. For example:

<BlogList>
  <li>The page ``/`` renders the JS file ``app/page.js``</li>
  <li>The page ``/blog`` renders the JS file ``app/blog/page.js``.</li>
  <li>
    The page ``projects/[id]`` renders the JS file ``app/projects/[id]/page.js``
    (yes, this folder structure works for dynamic fetching as well!)
  </li>
</BlogList>

With that being said, my home page's source code (`app/page.js`) will be shown below!

<BlogCode language="js">
{`
export default function Home() {
  return (
    <div className="space-y-5">
      <p>
        latest news: <a href="/blog/cat-or-car">cat or car project</a>
      </p>

      <br />
      <p>hi, im bryan.</p>
      <p>heres some stuff about me:</p>
      <ul className="list-disc mx-6 space-y-2">
        <li>
          ...
        </li>
        ...
      </ul>
      ...

);
}

`}

</BlogCode>

Of course, I'm not gonna show all of it. If you want to see all of it, you can just go to my full source code (in the footer).\
\
The important part here is the use of Tailwind CSS! As you can see, the div and unordered list both have styling.
The property name becomes "className" (as opposed to "class" in HTML). Now...what do the classes do? \
\
The class "space-y-5" causes all the inner elements to be separated vertically. It essentially just adds

<br />

```
margin-top: 1.25rem;
```

\
to the element. Meanwhile, the "mx-6" sets the margin of each child element! \
\
The great thing about Tailwind is that the documentation is very easily readable. You can actually just search up
"tailwind space between" and get the classnames required to do what you want! \
\

<a href="https://tailwindcss.com/docs/installation" target="_blank">
  here
</a> 
is the link to the docs!

<BlogImage
  src="/blogs/pdev-ep1-latex-and-code/tailwind-docs.png"
  alt="Tailwind docs - margin"
  caption="Look at these beautiful Tailwind docs"
/>

Now, you may notice that I'm missing a navbar. Where is it???

<br />

## layout.js and Components

One of the great things about Next (and React) is components. You can make custom JS files that are both
reusable and independent to the rest of the code where the component is used. For example, I have a few components:

<BlogList>
  <li>Navbar - to render the navigation bar at the top of my page</li>
  <li>
    BlogList - to make lists in my blog (you are literally looking at it right
    now)
  </li>
  <li>BlogCode - to add code into my blog</li>
  <li>LatexWrapper - to add LaTeX into my blog</li>
</BlogList>

In order to make a component, you just need a JS file. I like to keep my stuff organized, so I have a folder:
`src/components`. To give an example, I'll show you my navbar code (`src/components/Navbar.js`).

<BlogCode language="js">
{`
import Link from "next/link";

const Navbar = () => {
return (

  <nav className="bg-transparent flex justify-between items-center p-0 h-48 md:h-32">
    <div className="inline space-y-2 md:flex">
    <Link href="/" className="flex m-0 items-center">
      <p className="inline text-2xl text-purple-200 text-nowrap font-bold align-middle">
      bryan chan.
      </p>
    </Link>
      <Link href="/" className="flex m-0 items-center md:hidden">
      <p className="inline text-2xl text-purple-200 text-nowrap font-bold align-middle">
      -- home
      </p>
    </Link>
    ...
    </div>

    <ul className="space-x-6 hidden md:flex">
      <li>
        <Link href="/">
          <p className="text-2xl text-purple-200 font-bold">home</p>
        </Link>
      </li>
      ...
    </ul>
  </nav>

);
};

export default Navbar;

`}

</BlogCode>

The reason I have a duplicate link to each page is for responsiveness. If you read the Tailwind CSS, you can see the word "hidden" in the class name.
This is a Tailwind class that hides the element on a certain screen size. In this case, the navbar is rendered differently on mobile screens. \
\
It is important to note that Tailwind is mobile-first. This means that the classes you write will be applied to all screen sizes **and larger** unless you specify otherwise. \
\
If you would like to understand the CSS better, I highly recommend checking out the <a href="https://tailwindcss.com/docs" target="_blank">Tailwind docs</a>! \
\
Now...earlier, I mentioned that the navbar component was not in my home page's code. How did I add it? This is where **layout** comes in.
This file (`app/layout.js`) is a wrapper for all of my pages. This is where I add my navbar and footer. Everything else is rendered in the `{children}` prop.

<BlogCode language="js">
{`
import { Inter } from "next/font/google";

import "./globals.css";

import Navbar from "@/components/Navbar";

const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "bryan",
  description: "a typical cs portfolio",
};

export default async function RootLayout({ children }) {
  console.log(process.env.COMMIT_HASH);
  return (
    <html lang="en">
      <body className={\`$\{inter.className\} overflow-x-hidden\`}>
        <main className="w-screen">
          <Navbar />
          {children}
          <footer className="bg-transparent text-">
            <p>.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.</p>
            {process.env.COMMIT_HASH && (
              <p>
                last commit hash:{" "}
                <a
                  href={\`https://github.com/brrryry/personal-website/commit/$\{process.env.FULL_COMMIT_HASH\}\`}
                  target="_blank"
                >
                  {process.env.COMMIT_HASH}
                </a>{" "}
                | web version: {process.env.APP_VERSION}
              </p>
            )}
            blahblahblah...
          </footer>
        </main>
      </body>
    </html>
  );
`}
</BlogCode>

As you can see, the navbar component is rendered at the top of the page! \
\
All in all, this becomes very useful when you have a lot of pages that need the same components. Now...onto the next section!

<br />

## The Blog Page

The blog page is a bit more complicated than the home page. This is because I have to parse the frontmatter and content of the .mdx files from a different directory. \
\
All of my .mdx files are in the `src/posts` directory. The blog page (`app/blog/page.js`) is shown below.

<BlogCode language="js">
{`
import { getSortedPostsData } from "@/lib/posts";

export default async function Blog() {
  const allPostsData = await getSortedPostsData();
  let allTags = [];
  allPostsData.forEach((post) => {
    allTags = allTags.concat(post.data.tags);
  });
  allTags = [...new Set(allTags)];
  allTags = allTags.sort((a, b) => a.localeCompare(b));

return (

  <div className="flex">
    <div className="space-y-5 md:w-4/5">
      <ul>
        {allPostsData.map((post) => {
        if (post)
        return (
        <li key={post.id} className="py-2">
          <p>
          <a href={\`/blog/$\{post.id\}\`}>{post.data.title}</a> (
            {post.data.date})
            <br />
            tags: [
            {post.data.tags.map((tag, i) => {
              return (
                <a href={\`/blog/tag/$\{tag\}\`} key={post.id + tag}>
                {i < post.data.tags.length - 1 ? tag + ", " : tag}
                </a>
                );
                })}
            ]<br />
            {post.data.description}
          </p>
        </li>
        );
        })}
      </ul>
  </div>
  <div className="justify-end text-right hidden md:block md:w-1/5"> - - -<br />
  tags
  <div>
  <a href="/blog">all</a>
  <br />
  </div>
  {allTags.map((tag, i) => {
  return (
    <div key={tag + i}>
    <a href={\`/blog/tag/$\{tag\}\`}>{tag}</a>
  <br />
  </div>
  );
  })}
  </div>
  </div>
);
}
`}

</BlogCode>

The important part here is the use of the `getSortedPostsData()` function. This function is in the `src/lib/posts.js` file. The "@" symbol
is a shortcut to the "src" directory (we told the program not to change that shortcut when we initially set up the project). \
\
Since this file is not in the App Router (`src/app`), it is not able to be accessed by the browser. This means that the function is only used in the server-side rendering of the page.
This ended up causing some problems for me later, but we'll get to that when we cover it. \
\
The function essentially reads all the .mdx files in the `src/posts` directory and returns them in a sorted array. It also gets all blog tags and returns them to be rendered.

<BlogCode language="js">
{`
export function getSortedPostsData(tag = "") {
  // Get file names under /posts
  const fileNames = fs.readdirSync(postsDirectory);
  const allPostsData = fileNames
    .map((fileName) => {
      const id = fileName.replace(/\.mdx$/, "");

      // Read markdown file as string
      const fullPath = path.join(postsDirectory, fileName);
      const fileContents = fs.readFileSync(fullPath, "utf8");

      // Use gray-matter to parse the post metadata section
      const matterResult = matter(fileContents);
      // Combine the data with the id

      if (tag.length === 0 || matterResult.data.tags.includes(tag)) {
        return {
          id,
          ...matterResult,
        };
      }
    })
    .filter(Boolean);

// Sort posts by date
return allPostsData.sort((a, b) => {
if (a.data.date < b.data.date) {
return 1;
} else {
return -1;
}
});
}
`}

</BlogCode>

This function uses the `fs` and `path` modules to read the files in the directory. It then uses the `gray-matter` package to parse the frontmatter of the .mdx files. \
\
The function also takes in a tag as an argument. If the tag is not empty, the function will only return posts with that tag. This version of the function is used to render blogs in
the page `/blog/[tag]/tag` (filtered blogs by tag).
\
Now, let's get into the actual blog post page! Here is the code for the page `app/blog/[id]/page.js` (you're looking at this page right now)!

<BlogCode language="js">
{`
import React from "react";
import { MDXRemote } from "next-mdx-remote/rsc";
import { getPostFromId } from "@/lib/posts";

import { LatexWrapper } from "@/components/LatexWrapper";
import { BlogImage } from "@/components/BlogImage";
import { BlogList } from "@/components/BlogList";
import { BlogCode } from "@/components/BlogCode";

import NotFound from "@/app/[...not_found]/page";

//import code highlighting css
import "@/../public/styles/atom-one-dark.css";

export default async function BlogPost({ params }) {
  //get the files from posts/params.id

const { content, data, notFound } = await getPostFromId(params.id);

if (notFound) {
return <NotFound />;
}

return (

<div className="flex justify-center">
<article className="min-w-0 max-w-4xl"> - - -<h3>{data.title}</h3>
<p>created on {data.date}</p>
<p>
tags: [
{data.tags.map((tag, i) => {
return (
<a href={\`/blog/tag/$\{tag\}\`} key={tag}>
{i < data.tags.length - 1 ? tag + ", " : tag}
</a>
);
})}
] <br />- - -
</p>
<MDXRemote
source={content}
components={{ LatexWrapper, BlogImage, BlogList, BlogCode }}
/>
</article>
</div>
);
}
`}

</BlogCode>
The first part of my return statement simply renders the frontmatter of the .mdx file in a slightly nicer format. \
\
The ``getPostFromId()`` function is in the same file as the ``getSortedPostsData()`` function. It reads the .mdx file with the id ``params.id`` and returns the content and frontmatter. \
\
The ``MDXRemote`` component is used to render the content. The ``components`` prop is used to render custom components (the ones I made) in the content. This allows me to write something like

<BlogCode language="mdx">
  {`
<BlogCode language="js">
{\`
console.log("hello world");
\`}
</BlogCode>
`}
</BlogCode>

in my .mdx files! \
\
Now, let's get to the interesting part: **the process**. Most of the next section will be about the process of making the custom components - not the code itself. The tutorial basically
ends here.

<br />

## Blog Format and Components

**This part exists for the purpose of documenting my thought process.**\
\
I wanted to make my blog as readable as possible. This took me a long time to learn. Originally, my blog was just a bunch of text and HTML that spread across the entire page.
If you look at it now, it only takes up to a maximum of `56rem (896px)` of the page width. This was for the sake of responsiveness - it simply looked out of place when
viewing the original version of my blog on a mobile viewport. This was also due to the inspiration of other people's blogs, since most of them were also not a full page's width.

<BlogImage
  src="/blogs/pdev-ep1-latex-and-code/tumtarts.png"
  alt="Tumtarts blog"
  caption="Example: Tumtarts blog - a blog that inspired me :D"
  source="https://tumtarts.com"
  style={{ border: "0.5rem white solid" }}
/>

In the code shown earlier, you can see that the article tag has the class "min-w-0 max-w-4xl". This sets the minimum width of the article to 0 and the maximum width to 4xl.

<br />

For the most part, this helped my text stay readable. However, I also wanted to add a template for images, as it was getting painful to type out the HTML for each image. For example,
this was the HTML behind my first image in my blog (<a href="/blog/insure-2024">INSURE 2024</a>):

<BlogCode language="html">
{`
<br/>

<figure>
  <img
    src="https://news.engineering.iastate.edu/files/2024/07/ECE-INSURE-Students-1-1024x576.jpg"
    alt="us at a tractor"
  />
  <p>fig 1 - visiting the <a href="https://www.deere.com/en/stories/featured/cyber-tractor-challenge-2024/" target="_blank">2024 cyber tractor challenge</a> (<a href="https://news.engineering.iastate.edu/2024/07/18/iowa-state-hosts-first-insure-cybersecurity-workshop-in-the-country/" target="_blank">image citation</a>)</p>

</figure>

<br/>
`}
</BlogCode>

I was getting quite tired of copy and pasting the same code over and over again. This is where the `BlogImage` component comes in. Now, I am able to write this instead:

<BlogCode language="html">
  {`
<BlogImage 
src="/blogs/pdev-ep1-latex-and-code/tumtarts.png"
alt="Tumtarts blog"
caption="Example: Tumtarts blog - a blog that inspired me :D"
source="https://tumtarts.com"
style={{border: "0.5rem white solid"}}
/>
`}
</BlogCode>

(This is the code for the image above) \
It makes things easier and more readable when I am reviewing my blogs. \
\
Now, let's talk about the LaTeX. When I was writing my last blog (<a href="/blog/cat-or-car">Cat or Car</a>), I wanted to explain some of the basic math behind a neural network.
However, I was not able to render it in a nice format without LaTeX. I spent a lot of time trying to figure out how to use <a href="https://katex.org" target="_blank">KaTeX</a> in my blog,
but I was not able to get it to work. This is specifically because I needed the LaTeX to render in the server-side rendering of the page (otherwise, I had to rewrite my lib functions
that I mentioned earlier). After spending about 2 days, I found a much simpler answer - a math API. \
\
The math API I used was <a href="https://math.vercel.app/home" target="_blank">the math API Vercel app</a>. By passing in a LaTeX string, I was able to get a PNG image of the rendered
LaTeX. It was kind of a lazy workaround, but...it works. \
\
After getting the image, I needed to render it - preferably automatically - to scale, since not all LaTeX expressions would be the same size.
In order to do this seamlessly, I made the `LatexWrapper` component. This component takes in a LaTeX string and renders the image in a way that scales with the text. It estimates
the size of the image based on the length of the text I pass in.

<BlogCode language="html">
  {`
<LatexWrapper content="\\sum_{i=1}^{n} i = \\frac{n(n+1)}{2}"/>
`}
</BlogCode>

Gives me this:

<LatexWrapper content="\sum_{i=1}^{n} i = \frac{n(n+1)}{2}" />

Cool! Now I can write math in my blog. But...what about code? \
\
Originally, I just used the `<code>` tag to write code. However, it looked super ugly. In order to get syntax highlighting, I used the `rehype` package.
This package adds classes to the code tags in the .mdx files. I then used the `BlogCode` component to render the code. This component takes in a language prop and a content prop. \
\
Thankfully, since the `BlogCode` component was a sub-component, I could render it on the client side. This meant that I could use the `highlight.js` package to render the code.
I also used the file `atom-one-dark.css` to style the "classified" code (the import line is in the main blog page).

<BlogCode language="js">
{`
export function BlogCode({ children, language, ...props }) {
  const [code, setCode] = useState("");

children = \`<pre className="text-base lg: text-lg"><code className="language-$\{language\}">$\{renderToString(children)\}</code></pre>\`;
useEffect(() => {
(async () => {
const code = await rehype()
.data("settings", { fragment: true })
.use(rehypeHighlight)
.use(rehypeCodeLines, {
showLineNumbers: true,
lineContainerTagName: "div",
})
.process(children);
const cleanCode = DOMPurify.sanitize(code.toString());
setCode(cleanCode);
})();
}, []);

if (code === "") {
return <div>Loading...</div>;
}

return (

<>
  <br />
  <div className="" dangerouslySetInnerHTML={{ __html: code }} />
  <br />
</>
); } `}

</BlogCode>

The `DOMPurify` package is used to sanitize the code. This is to prevent cross-scripting XSS attacks (code injection). \
\
Now, I can write code in my blog! \
\
That's basically all I have so far, so let's jump to our final section:

<br />

## Conclusion + Future Work?

It's been a while since I've touched NextJS (or any JavaScript for that matter), so this was a nice refresher. I am also happy that I am blogging, since this is a way to
document my progress! \
\
There are a few things that I would like to do in the future:

<BlogList>
  <li>Add a search bar to my blog</li>
  <li>
    Add a pagination system to my blog (especially if I keep blogging at this
    frequency)
  </li>
  <li>Add a Spotify API to my blog (maybe see what I'm listening to?)</li>
  <li>
    Further optimize my blog components - maybe create new ones on demand (maybe
    cooking related, since I'm trying to learn how to cook - blog coming soon?)
  </li>
</BlogList>

I hope you enjoyed this blog! I will be back soon with another one. \
\
If you have anything you'd like to or ask about (or suggest improvements), feel free to <a href="/">reach out</a> I always love talking to new people :)\
\
That's it! Byebye~