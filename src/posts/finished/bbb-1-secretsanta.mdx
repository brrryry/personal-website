---
title: "Secret Santa"
date: "2024-12-05"
description: "I made a scuffed Secret Santa generator for my friends with weird authentication"
tags: ["coding"]
---

Yikes, I guess I did leave this portfolio hanging a bit...haven't touched it in a while.
However, I have something cool to show you! 
# Secret Santa Website
## Link to the project: <s><a href="">here</a></s> taken down

<br />

That's right, I made a web app! \
However, things were not just sunshine and rainbows. That's why I wanted to write this! \
\
Baffling Built Brainstorms will be a series of posts where I talk about **every** single project I have made.
No matter how flawed it is, I will post it here. \
\
Now, let's get into the website. 

## Synopsis
I came up with the idea of making this website on the 2nd of December, 2024.
My friends wanted to run a Secret Santa, and I wanted to put something on my portfolio.
This seemed to make logical sense. \
\
This also meant that I had to make a website that was **actually** usable in approximately 3 days... 

## The OG Architecture Plan
I used NextJS. \
Originally, I wanted to make a website that was reasonably secure. 
<BlogList>
<li><u>/</u> -> landing page</li>
<li><u>/sslist</u> -> people </li>
<li><u>/profile/:id</u> -> profile</li>
<li><u>/signup</u> -> signup page (two components, codechecker and actual signup page)</li>
<li><u>/api/code</u> -> code checking for signups (the code blocks unwanted people from signing up)</li>
<li><u>/api/sslist</u> -> send out emails </li>
<li><u>/api/signup</u> -> signup</li>
<li><u>/api/users/\*</u> -> get either all users or one user's data</li>
</BlogList>

In retrospect, this could have worked perfectly fine. I don't actually remember why I didn't go with this plan.
It was probably something about being paranoid that someone could just take the code and spam signups. Because of this,
I implemented a weird authentication system.

## The Authentication System
I wanted to make sure that only people with the code could sign up.
This part was not too hard. I made a code checking component and a signup component.

<BlogCode title="/src/components/CodeForm.js" language="js">
{`
"use client"

import {useState} from 'react';
import xss from 'xss'

export function CodeForm({callback}) {

  const [error, setError] = useState(null);
 
  async function handleSubmit(event) {
    event.preventDefault()
 
    const formData = new FormData(event.currentTarget)
    
    const code = xss(formData.get('code'))

    const response = await fetch(process.env.SUB_URL + 'api/auth/code', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ code }),
    })
 
    if (response.ok) {
      setError("");
      callback();
    } else {
        let err = await response.json()
      setError(err.error);
    }

  }
 
  return (
    <form onSubmit={handleSubmit}>
      <div className="m-5">
        <label htmlFor="code" className="mx-3 black">code</label>
        <input type="code" name="code" placeholder="code" required />
      </div>

      <button type="submit">submit</button>

      {error && <p>{error}</p>}
    </form>
  )
}
`}
</BlogCode>

<BlogCode title="/src/app/signup/page.js" language="js">
{`
"use client"

import {useState} from 'react';

import {CodeForm} from '@/components/CodeForm.js';
import {SignupForm} from '@/components/SignupForm.js';


export default function Signup() {
    const [lock, setLock] = useState(true);


    function callback() { //if this is called, code is valid.
        setLock(false);
    }


    return (
        <div>
            {lock && 
            <div>
                <p>wait! u need a code</p>
                <CodeForm callback={callback} />
            </div>
            }
            {!lock &&
            <div>
                <p>signup</p>
                <SignupForm />
            </div>
            }
        </div>
    )
}
`}
</BlogCode>

This way, the code form and the signup form can be on the same page. \
The signup form was relatively easy to make. 

<br />

### But of course, I had to make things harder.

## The Actual Authentication System
The issue was not with the code checking. The issue was with actually creating/logging into accounts. I tried using <a href="https://next-auth.js.org/" target="_blank">NextAuth</a>, but it was not working for me. \
I ended up making my own authentication system, and it was not the way I thought it would be. \
\
I made a user database with each user's email, password (hashed) and username in a JSON file. I didn't want to go through the effort
of setting up a SQLite database or an external server (because this database is intuitively small). \
\
Upon signup, the user would be added to the database. Upon login, the user would be checked against the database. This part was okay. \
\
The problem was maintaining the session. I had to make sure that the user could stay logged in, and I was not able to get ``res.setCookie()`` to work for some reason.
Because of this, I ended up passing the cookie through the API response upon a successful POST request. This cookie was just the encrypted username and time of signin. 

<BlogCode title="example response from /login" language="json" copy="false">
{`
{
  success: true,
  cookie: 'encrypted username and time'
}
`}
</BlogCode>
It would then be the client's job to store this cookie and send it back to the server upon every request. This was not the best way to do it, but it worked at the moment. \
\
Now, I had to check if the cookie was valid whenever a request was made. This was done through a middleware function that decrypted the cookie and checked the username.
As far as I know at the moment, this way of doing it was pretty secure. Obviously, I'm not gonna tell you what encryption/decryption algorithm I used (teehee). \
\
The problem was that I had to do this for every single API route. Because of this, I usually got spammed with 401 errors whenever I visited a page.
Since the client repeatedly tried to get other static resources that NextJS generates, I got a lot of network traffic. 

<BlogImage
  src="/blogs/bbb-1-secretsanta/routespam.png"
  alt="Image of getting route spammed with 500 status"
  caption="Ya boy was spamming the routes"
/>

Since I was running out of time (and I was too lazy to fix this), I just left it as is. However, I could just check if the resource being requested was static. 
This was (and still is) one of the bigger flaws of this website. \
\
Since the authentication cookie was in the client's hands, I had to grab it and send it with every request.
This was done by having my ``page.js`` files being server side and fetching the cookie from the headers and passing it to a client component. 
All in all, this was a very messy way of doing things. If I were to do it again, maybe I would just use NextAuth (TVT)

<br />

## The Secret Santa Part
This did not take that long. I just made a page that displayed everyone's names and emails. Additionally, I made a button for myself
that would send out all the emails. I did it this way so that I couldn't see who everyone's Secret Santa was - it would be shuffled in the program
and sent out to everyone's emails without me being able to view how it was shuffled. \
\
In order to do this, I used the <a href="https://nodemailer.com/" target="_blank">Nodemailer</a> package. 
I made an account on my domain that would send out the emails. \
\
However, I found out that it had issues with sending out emails to Gmail accounts. I still have no idea why, and I just told my friends to use a different domain. \
\
The rest of my time after this project was spent on getting it self hosted. 
A blog will be written soon about that part, but long story short - it took a while. \
\
I ended up finishing the project on the 5th of December, 2024. I was pretty happy with it (although there are many things to be improved).

<br />

## Funny Vulnerabilities and Stupid Things
I will list some of the funny things that I (or other people) find on this project. This will (hopefully) be updated over time.

<BlogList>
<li><u>DDOS (2024-12-04)</u> <br/> - I found out that it is hilariously easy to take down the API. Since I was spamming the middleware function (which sent requests to my API)
it would take down the API if I simply spammed the routes. I don't think it's bad to the point where a single person spamming refresh would kill it, but 
it is definitely particularly vulnerable to DOS attacks.</li> 
<p><br/></p>
<li><s><u>Wireshark (2024-12-06) [Collin Shen]</u></s> fixed by implementing HTTPS<br/> - When authenticating on the ``/login`` page, the username and password are sent in plaintext.
This is a huge vulnerability if someone were to use Wireshark to sniff the data on the network (especially if the password was correct).</li> 
</BlogList>

## Conclusion
This project was fun. A lot of the stuff I learned wasn't from the project itself, but the process of deploying it.
However, I did learn how to use Nodemailer and how SMTP servers work on a high level. \
\
Anyways, I hope you enjoyed this post. I will be making more scuffed projects in the future, so stay tuned :) \
\
Peace out. \
\
(Edit 2024-12-16: the self hosting blog is now out. Check it out <a href="/blog/pdev-ep2-cicd">here</a>.)